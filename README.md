# SIMD-Trapezoidal-rule
Реализация метода трапеций с векторными инструкциями

Метод трапеций — метод численного интегрирования функции одной переменной, заключающийся в замене на каждом элементарном отрезке подынтегральной функции на многочлен первой степени, то есть линейную функцию. Площадь под графиком функции аппроксимируется прямоугольными трапециями. Алгебраический порядок точности равен 1.

## Выравнивание данных
```cpp
alignas(32) float x_vals_arr[8]; // Глобальный массив для выровненных данных
```
AVX-регистры работают с 256-битными блоками (8 float по 4 байта = 32 байта).
Если данные не выровнены по границе 32 байт, доступ к ним может привести к снижению производительности или даже сегментационному сбою.

Используем alignas(32), чтобы гарантировать выравнивание массива по границе 32 байта.

## Реализация

```cpp
float rectangle_method_simd(float (*f)(float), float a, float b, int n) {
    // Вычисляем шаг разбиения
    float delta_x = (b - a) / n;

    // Вектор, в котором будем накапливать сумму значений функции
    __m256 integral_vec = _mm256_setzero_ps();

    // Ширина SIMD-регистра в элементах (AVX использует 8 float за раз)
    int simd_width = 8;
    
    // Ограничиваем количество итераций кратным 8 (чтобы избежать выхода за границы массива)
    int simd_end = n - (n % simd_width);

    // Основной цикл по 8 значений за раз
    for (int i = 0; i < simd_end; i += simd_width) {
        // Создаем вектор индексов: [i, i+1, ..., i+7]
        __m256 indices = _mm256_set_ps(i + 7, i + 6, i + 5, i + 4, i + 3, i + 2, i + 1, i);
        
        // Вычисляем x_i: x_i = a + i * delta_x
        __m256 x_vals = _mm256_add_ps(_mm256_mul_ps(indices, _mm256_set1_ps(delta_x)), _mm256_set1_ps(a));

        // Сохраняем в массив для использования в скалярных вызовах функции f
        alignas(32) float x_vals_arr[8];
        _mm256_store_ps(x_vals_arr, x_vals);

        // Вычисляем значения функции f(x) для всех 8 элементов
        __m256 f_vals = _mm256_set_ps(f(x_vals_arr[7]), f(x_vals_arr[6]), f(x_vals_arr[5]), f(x_vals_arr[4]),
                                      f(x_vals_arr[3]), f(x_vals_arr[2]), f(x_vals_arr[1]), f(x_vals_arr[0]));

        // Добавляем результаты в вектор суммы
        integral_vec = _mm256_add_ps(integral_vec, f_vals);
    }

    // Сохраняем накопленную сумму из вектора в массив
    alignas(32) float integral_arr[8];
    _mm256_store_ps(integral_arr, integral_vec);

    // Просуммируем все 8 элементов вектора
    float integral = 0;
    for (int i = 0; i < 8; ++i) {
        integral += integral_arr[i];
    }

    // Обрабатываем оставшиеся элементы (если n не кратно 8)
    for (int i = simd_end; i < n; ++i) {
        integral += f(a + i * delta_x);
    }

    // Возвращаем результат с учетом delta_x
    return integral * delta_x;
}
```

1. **SIMD-регистр (`__m256`)**  Используется для хранения 8 значений одновременно, что позволяет выполнять вычисления над ними параллельно.

2. Проходит по массиву с шагом 8, загружая данные в `__m256` и выполняя векторные операции. Это позволяет значительно ускорить вычисления по сравнению с обычным скалярным циклом.

3.  Так как стандартные математические функции (например, `sin(x)`) не поддерживают работу с SIMD-регистрами, приходится извлекать значения `x` в массив и вызывать `f(x)` последовательно для каждого элемента.

4. Если `n` не кратно 8, оставшиеся значения (менее 8) вычисляются обычным `for`, так как для них векторные инструкции не применимы.
